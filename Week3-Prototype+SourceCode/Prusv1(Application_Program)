from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend
import os
import requests

def show_header():
    print('    ------------------------------------------------------------------')
    print('    |                    |                      |                    |')
    print('    |                    | Developed   by       |                    |')
    print('    |The Prus Program v1.|                      | CMPS-6520 Advanced |')
    print('    |                    | Jonathan Persaud     | Storage Systems    |')
    print('    |                    |                      |                    |')
    print('    ------------------------------------------------------------------')


def encrypt_and_upload():
    file_path = input("Enter the full path of the file to encrypt and upload: ").strip()
    if not os.path.isfile(file_path):
        print("Error: File does not exist.")
        return

    # generate AES-256 key and IV *See ProjectReport for explanation
    key = os.urandom(32)
    iv = os.urandom(16)
    print(f"Save this AES-256 key securely: {key.hex()}")

    # read the file
    with open(file_path, 'rb') as f:
        plaintext = f.read()

    # pad plaintext
    padder = padding.PKCS7(128).padder()
    padded_data = padder.update(plaintext) + padder.finalize()

    # encrypt the file
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    ciphertext = encryptor.update(padded_data) + encryptor.finalize()

    # write IV + ciphertext to file
    name, _ = os.path.splitext(os.path.basename(file_path))
    encrypted_file = name + ".aes"
    with open(encrypted_file, 'wb') as f:
        f.write(iv + ciphertext)
    print(f"File encrypted successfully as: {encrypted_file}")

    # Upload to IPFS backend node
    print("Uploading encrypted file to IPFS...")
    api_url = "http://127.0.0.1:5001/api/v0/add?pin=true"
    try:
        with open(encrypted_file, 'rb') as f:
            response = requests.post(api_url, files={'file': f})
        if response.status_code == 200:
            cid = response.json()['Hash']
            print(f"File uploaded to IPFS. CID: {cid}")
            print("Save this information:")
            print(f"AES-256 Key: {key.hex()}")
            print(f"IPFS CID:    {cid}")

            # create MFS folder if not exists (I need to do this for visibilty in the GUI)
            api_url_mkdir = "http://127.0.0.1:5001/api/v0/files/mkdir?arg=/encrypted_files&parents=true"
            mkdir_response = requests.post(api_url_mkdir)
            if mkdir_response.status_code == 200:
                print("MFS directory '/encrypted_files' created.")
            elif "file already exists" in mkdir_response.text:
                print("MFS directory '/encrypted_files' already exists.")
            else:
                print(f"Failed to create MFS directory: {mkdir_response.text}")

            # copy file to MFS
            mfs_path = f"/encrypted_files/{os.path.basename(encrypted_file)}"
            api_url_mfs = f"http://127.0.0.1:5001/api/v0/files/cp?arg=/ipfs/{cid}&arg={mfs_path}"
            mfs_response = requests.post(api_url_mfs)
            if mfs_response.status_code == 200:
                print(f"File added to MFS at: {mfs_path}")
            else:
                print(f"Failed to add file to MFS: {mfs_response.text}")
        else:
            print(f"IPFS upload failed: {response.text}")
    except Exception as e:
        print(f"Could not connect to IPFS API: {e}")

def download_and_decrypt():
    aes_key_hex = input("Enter the AES-256 key (hex): ").strip()
    cid = input("Enter the IPFS CID: ").strip()

    # convert AES key from hex
    try:
        key = bytes.fromhex(aes_key_hex)
        if len(key) != 32:
            raise ValueError("Invalid AES-256 key length.")
    except Exception as e:
        print(f"Error: {e}")
        return

    # download encrypted file
    print("Downloading encrypted file from IPFS...")
    api_url = f"http://127.0.0.1:8080/ipfs/{cid}"
    try:
        response = requests.get(api_url)
        if response.status_code == 200:
            encrypted_data = response.content
            print("Encrypted file downloaded successfully.")
        else:
            print(f"Failed to download from IPFS: {response.text}")
            return
    except Exception as e:
        print(f"Could not connect to IPFS gateway: {e}")
        return

    # split IV and ciphertext
    iv = encrypted_data[:16]
    ciphertext = encrypted_data[16:]

    # ddecrypt
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    decryptor = cipher.decryptor()
    padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()

    # npad plaintext
    unpadder = padding.PKCS7(128).unpadder()
    try:
        plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()
    except ValueError:
        print("Decryption failed: Invalid padding or wrong AES key.")
        return

    # We could easily modify this to save as the original name, for clarity i labeled it decrypted_file to make it obvious 
    # which file it is becasue iim testing on the same system as the original file
    output_file = "decrypted_file.txt"
    with open(output_file, 'wb') as f:
        f.write(plaintext)
    print(f"File decrypted successfully as: {output_file}")

def main():
    show_header()
    while True:
        print("\n--- Menu ---")
        print("1. Encrypt and upload a file")
        print("2. Download and decrypt a file")
        print("3. Exit")
        choice = input("Select an option (1-3): ").strip()

        if choice == '1':
            encrypt_and_upload()
        elif choice == '2':
            download_and_decrypt()
        elif choice == '3':
            print("Exiting.")
            break
        else:
            print("Invalid option. Please select 1, 2, or 3.")

if __name__ == "__main__":
    main()
